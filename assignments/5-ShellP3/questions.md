1. Your shell forks multiple child processes when executing piped commands. How does your implementation ensure that all child processes complete before the shell continues accepting user input? What would happen if you forgot to call waitpid() on all child processes?

My implementation ensures that all child processes complete before the shell continues accepting user input by using waitpid() in a loop. When executing a piped command, the shell forks multiple child processes, each responsible for a stage in the pipeline. After forking all processes, the parent shell iterates through their process IDs and calls waitpid() to wait for each child to terminate before displaying the next command prompt. If waitpid() were not used, child processes would become zombie processes, remaining in the systemâ€™s process table until explicitly collected by the parent. Over time, these zombie processes could accumulate and exhaust system resources, leading to performance issues.

2. The dup2() function is used to redirect input and output file descriptors. Explain why it is necessary to close unused pipe ends after calling dup2(). What could go wrong if you leave pipes open?

The dup2() function is used to redirect input and output file descriptors, making it essential to close unused pipe ends afterward. If pipes are left open, several problems can occur. One major issue is deadlocks, if a process expects input from a pipe but the write end remains open, it may never receive an EOF signal and could hang forever. Additionally, open file descriptors consume system resources and excessive open pipes could lead to file descriptor exhaustion, preventing new processes from creating pipes.

3. Your shell recognizes built-in commands (cd, exit, dragon). Unlike external commands, built-in commands do not require execvp(). Why is cd implemented as a built-in rather than an external command? What challenges would arise if cd were implemented as an external process?

The cd command is a built-in because it directly changes the current working directory of the shell process. If it were external, it would run in a child process, and any changes would be lost once the child terminates. The parent shell would remain in the same directory, making it ineffective. To modify the parent shell's directory, chdir() must be called within the shell, making cd a built-in for efficiency.

4. Currently, your shell supports a fixed number of piped commands (CMD_MAX). How would you modify your implementation to allow an arbitrary number of piped commands while still handling memory allocation efficiently? What trade-offs would you need to consider?

The shell currently uses a fixed number of piped commands with a predefined array size (CMD_MAX). To support an arbitrary number of commands while managing memory efficiently, dynamic allocation can be used. Instead of a static array, malloc() can allocate memory, and realloc() can expand it as needed. While this offers flexibility, it introduces overhead and requires careful memory management to avoid leaks or overflows. A balanced approach is to start with a reasonable default allocation and expand only when necessary for efficiency.
